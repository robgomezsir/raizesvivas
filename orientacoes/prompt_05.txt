# üìã Prompt 05 - Repositories e Firestore Services

## üéØ Objetivo
Criar camada de Repository que integra Room (local) com Firestore (remoto) e implementar servi√ßos Firebase.

---

## üî• PARTE 1: Firestore Service

### Arquivo: data/remote/firebase/FirestoreService.kt

```kotlin
package com.raizesvivas.app.data.remote.firebase

import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.raizesvivas.app.domain.model.*
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import timber.log.Timber
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Servi√ßo para opera√ß√µes no Cloud Firestore
 * 
 * Responsabilidades:
 * - CRUD de pessoas, usu√°rios, convites
 * - Queries espec√≠ficas
 * - Listeners em tempo real
 */
@Singleton
class FirestoreService @Inject constructor(
    private val firestore: FirebaseFirestore
) {
    
    // Refer√™ncias de collections
    private val usersCollection = firestore.collection("users")
    private val peopleCollection = firestore.collection("people")
    private val familiaZeroCollection = firestore.collection("familia_zero")
    private val invitesCollection = firestore.collection("invites")
    private val pendingEditsCollection = firestore.collection("pending_edits")
    private val duplicatesCollection = firestore.collection("duplicates")
    
    // ============================================
    // USU√ÅRIOS
    // ============================================
    
    /**
     * Cria ou atualiza usu√°rio no Firestore
     */
    suspend fun salvarUsuario(usuario: Usuario): Result<Unit> {
        return try {
            val data = hashMapOf(
                "nome" to usuario.nome,
                "email" to usuario.email,
                "fotoUrl" to usuario.fotoUrl,
                "pessoaVinculada" to usuario.pessoaVinculada,
                "ehAdministrador" to usuario.ehAdministrador,
                "familiaZeroPai" to usuario.familiaZeroPai,
                "familiaZeroMae" to usuario.familiaZeroMae,
                "primeiroAcesso" to usuario.primeiroAcesso,
                "criadoEm" to usuario.criadoEm
            )
            
            usersCollection.document(usuario.id)
                .set(data)
                .await()
            
            Timber.d("‚úÖ Usu√°rio salvo: ${usuario.id}")
            Result.success(Unit)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao salvar usu√°rio")
            Result.failure(e)
        }
    }
    
    /**
     * Busca usu√°rio por ID
     */
    suspend fun buscarUsuario(userId: String): Result<Usuario?> {
        return try {
            val snapshot = usersCollection.document(userId).get().await()
            
            if (!snapshot.exists()) {
                return Result.success(null)
            }
            
            val usuario = snapshot.toObject(Usuario::class.java)
            Result.success(usuario)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar usu√°rio")
            Result.failure(e)
        }
    }
    
    /**
     * Observa usu√°rio em tempo real
     */
    fun observarUsuario(userId: String): Flow<Usuario?> = callbackFlow {
        val registration = usersCollection.document(userId)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    Timber.e(error, "Erro ao observar usu√°rio")
                    close(error)
                    return@addSnapshotListener
                }
                
                val usuario = snapshot?.toObject(Usuario::class.java)
                trySend(usuario)
            }
        
        awaitClose { registration.remove() }
    }
    
    /**
     * Busca todos os administradores
     */
    suspend fun buscarAdministradores(): Result<List<Usuario>> {
        return try {
            val snapshot = usersCollection
                .whereEqualTo("ehAdministrador", true)
                .get()
                .await()
            
            val admins = snapshot.toObjects(Usuario::class.java)
            Result.success(admins)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar administradores")
            Result.failure(e)
        }
    }
    
    // ============================================
    // FAM√çLIA ZERO
    // ============================================
    
    /**
     * Verifica se a Fam√≠lia Zero j√° foi criada
     */
    suspend fun familiaZeroExiste(): Boolean {
        return try {
            val snapshot = familiaZeroCollection.document("raiz").get().await()
            snapshot.exists()
        } catch (e: Exception) {
            Timber.e(e, "Erro ao verificar Fam√≠lia Zero")
            false
        }
    }
    
    /**
     * Cria a Fam√≠lia Zero (apenas no primeiro acesso)
     */
    suspend fun criarFamiliaZero(familiaZero: FamiliaZero): Result<Unit> {
        return try {
            // Verificar se j√° existe
            if (familiaZeroExiste()) {
                return Result.failure(Exception("Fam√≠lia Zero j√° existe!"))
            }
            
            val data = hashMapOf(
                "pai" to familiaZero.pai,
                "mae" to familiaZero.mae,
                "fundadoPor" to familiaZero.fundadoPor,
                "fundadoEm" to familiaZero.fundadoEm,
                "locked" to true,
                "arvoreNome" to familiaZero.arvoreNome
            )
            
            familiaZeroCollection.document("raiz")
                .set(data)
                .await()
            
            Timber.d("üå≥ Fam√≠lia Zero criada!")
            Result.success(Unit)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao criar Fam√≠lia Zero")
            Result.failure(e)
        }
    }
    
    /**
     * Busca a Fam√≠lia Zero
     */
    suspend fun buscarFamiliaZero(): Result<FamiliaZero?> {
        return try {
            val snapshot = familiaZeroCollection.document("raiz").get().await()
            
            if (!snapshot.exists()) {
                return Result.success(null)
            }
            
            val familiaZero = snapshot.toObject(FamiliaZero::class.java)
            Result.success(familiaZero)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar Fam√≠lia Zero")
            Result.failure(e)
        }
    }
    
    /**
     * Observa a Fam√≠lia Zero em tempo real
     */
    fun observarFamiliaZero(): Flow<FamiliaZero?> = callbackFlow {
        val registration = familiaZeroCollection.document("raiz")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    Timber.e(error, "Erro ao observar Fam√≠lia Zero")
                    close(error)
                    return@addSnapshotListener
                }
                
                val familiaZero = snapshot?.toObject(FamiliaZero::class.java)
                trySend(familiaZero)
            }
        
        awaitClose { registration.remove() }
    }
    
    // ============================================
    // PESSOAS
    // ============================================
    
    /**
     * Salva pessoa no Firestore
     */
    suspend fun salvarPessoa(pessoa: Pessoa): Result<Unit> {
        return try {
            val data = hashMapOf(
                "nome" to pessoa.nome,
                "dataNascimento" to pessoa.dataNascimento,
                "dataFalecimento" to pessoa.dataFalecimento,
                "localNascimento" to pessoa.localNascimento,
                "localResidencia" to pessoa.localResidencia,
                "profissao" to pessoa.profissao,
                "biografia" to pessoa.biografia,
                "pai" to pessoa.pai,
                "mae" to pessoa.mae,
                "conjugeAtual" to pessoa.conjugeAtual,
                "exConjuges" to pessoa.exConjuges,
                "filhos" to pessoa.filhos,
                "fotoUrl" to pessoa.fotoUrl,
                "criadoPor" to pessoa.criadoPor,
                "criadoEm" to pessoa.criadoEm,
                "modificadoPor" to pessoa.modificadoPor,
                "modificadoEm" to pessoa.modificadoEm,
                "aprovado" to pessoa.aprovado,
                "versao" to pessoa.versao,
                "ehFamiliaZero" to pessoa.ehFamiliaZero,
                "distanciaFamiliaZero" to pessoa.distanciaFamiliaZero,
                "nomeNormalizado" to pessoa.nomeNormalizado
            )
            
            peopleCollection.document(pessoa.id)
                .set(data)
                .await()
            
            Timber.d("‚úÖ Pessoa salva: ${pessoa.nome}")
            Result.success(Unit)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao salvar pessoa")
            Result.failure(e)
        }
    }
    
    /**
     * Busca pessoa por ID
     */
    suspend fun buscarPessoa(pessoaId: String): Result<Pessoa?> {
        return try {
            val snapshot = peopleCollection.document(pessoaId).get().await()
            
            if (!snapshot.exists()) {
                return Result.success(null)
            }
            
            val pessoa = snapshot.toObject(Pessoa::class.java)
            Result.success(pessoa)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar pessoa")
            Result.failure(e)
        }
    }
    
    /**
     * Busca todas as pessoas
     */
    suspend fun buscarTodasPessoas(): Result<List<Pessoa>> {
        return try {
            val snapshot = peopleCollection
                .orderBy("nome", Query.Direction.ASCENDING)
                .get()
                .await()
            
            val pessoas = snapshot.toObjects(Pessoa::class.java)
            Timber.d("‚úÖ ${pessoas.size} pessoas carregadas")
            Result.success(pessoas)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar pessoas")
            Result.failure(e)
        }
    }
    
    /**
     * Observa todas as pessoas em tempo real
     */
    fun observarTodasPessoas(): Flow<List<Pessoa>> = callbackFlow {
        val registration = peopleCollection
            .orderBy("nome", Query.Direction.ASCENDING)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    Timber.e(error, "Erro ao observar pessoas")
                    close(error)
                    return@addSnapshotListener
                }
                
                val pessoas = snapshot?.toObjects(Pessoa::class.java) ?: emptyList()
                trySend(pessoas)
            }
        
        awaitClose { registration.remove() }
    }
    
    /**
     * Busca pessoas aprovadas
     */
    suspend fun buscarPessoasAprovadas(): Result<List<Pessoa>> {
        return try {
            val snapshot = peopleCollection
                .whereEqualTo("aprovado", true)
                .orderBy("nome", Query.Direction.ASCENDING)
                .get()
                .await()
            
            val pessoas = snapshot.toObjects(Pessoa::class.java)
            Result.success(pessoas)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar pessoas aprovadas")
            Result.failure(e)
        }
    }
    
    /**
     * Busca o casal da Fam√≠lia Zero
     */
    suspend fun buscarCasalFamiliaZero(): Result<List<Pessoa>> {
        return try {
            val snapshot = peopleCollection
                .whereEqualTo("ehFamiliaZero", true)
                .get()
                .await()
            
            val casal = snapshot.toObjects(Pessoa::class.java)
            Result.success(casal)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar casal Fam√≠lia Zero")
            Result.failure(e)
        }
    }
    
    /**
     * Deleta pessoa (apenas se N√ÉO for Fam√≠lia Zero)
     */
    suspend fun deletarPessoa(pessoaId: String): Result<Unit> {
        return try {
            // Verificar se n√£o √© Fam√≠lia Zero
            val pessoa = buscarPessoa(pessoaId).getOrNull()
            
            if (pessoa?.ehFamiliaZero == true) {
                return Result.failure(Exception("N√£o √© poss√≠vel deletar a Fam√≠lia Zero!"))
            }
            
            peopleCollection.document(pessoaId).delete().await()
            Timber.d("‚úÖ Pessoa deletada: $pessoaId")
            Result.success(Unit)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao deletar pessoa")
            Result.failure(e)
        }
    }
    
    // ============================================
    // BUSCA E QUERIES ESPECIAIS
    // ============================================
    
    /**
     * Busca pessoas por nome (pesquisa parcial)
     */
    suspend fun buscarPessoasPorNome(termo: String): Result<List<Pessoa>> {
        return try {
            val termoNormalizado = termo.lowercase()
            
            val snapshot = peopleCollection
                .orderBy("nomeNormalizado")
                .startAt(termoNormalizado)
                .endAt(termoNormalizado + "\uf8ff")
                .get()
                .await()
            
            val pessoas = snapshot.toObjects(Pessoa::class.java)
            Result.success(pessoas)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao buscar por nome")
            Result.failure(e)
        }
    }
    
    /**
     * Detecta poss√≠veis duplicatas
     * (mesmo nome, data de nascimento e pais)
     */
    suspend fun detectarDuplicatas(
        nome: String,
        dataNascimento: Date?,
        pai: String?,
        mae: String?
    ): Result<List<Pessoa>> {
        return try {
            var query = peopleCollection.whereEqualTo("nome", nome)
            
            if (dataNascimento != null) {
                query = query.whereEqualTo("dataNascimento", dataNascimento)
            }
            
            val snapshot = query.get().await()
            val possiveis = snapshot.toObjects(Pessoa::class.java)
            
            // Filtrar por pais
            val duplicatas = possiveis.filter { 
                it.pai == pai && it.mae == mae 
            }
            
            Result.success(duplicatas)
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao detectar duplicatas")
            Result.failure(e)
        }
    }
}
```

---

## üóÇÔ∏è PARTE 2: Repositories

### Arquivo: data/repository/PessoaRepository.kt

```kotlin
package com.raizesvivas.app.data.repository

import com.raizesvivas.app.data.local.dao.PessoaDao
import com.raizesvivas.app.data.local.entities.toDomain
import com.raizesvivas.app.data.local.entities.toEntity
import com.raizesvivas.app.data.remote.firebase.FirestoreService
import com.raizesvivas.app.domain.model.Pessoa
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import timber.log.Timber
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository para gerenciar pessoas
 * 
 * Este repository implementa o padr√£o Repository, coordenando:
 * - Dados locais (Room) para cache e modo offline
 * - Dados remotos (Firestore) como fonte da verdade
 * 
 * Estrat√©gia: Cache-First com sincroniza√ß√£o bidirecional
 */
@Singleton
class PessoaRepository @Inject constructor(
    private val pessoaDao: PessoaDao,
    private val firestoreService: FirestoreService
) {
    
    /**
     * Observa todas as pessoas (do cache local)
     * Atualiza automaticamente quando o cache muda
     */
    fun observarTodasPessoas(): Flow<List<Pessoa>> {
        return pessoaDao.observarTodasPessoas()
            .map { entities -> entities.map { it.toDomain() } }
    }
    
    /**
     * Busca pessoa por ID (cache local primeiro)
     */
    suspend fun buscarPorId(pessoaId: String): Pessoa? {
        // Buscar no cache local
        val local = pessoaDao.buscarPorId(pessoaId)?.toDomain()
        
        // Se n√£o estiver no cache, buscar no Firestore
        if (local == null) {
            val remoto = firestoreService.buscarPessoa(pessoaId).getOrNull()
            
            // Salvar no cache se encontrou
            remoto?.let {
                pessoaDao.inserir(it.toEntity())
            }
            
            return remoto
        }
        
        return local
    }
    
    /**
     * Sincroniza pessoas do Firestore para o cache local
     */
    suspend fun sincronizarDoFirestore(): Result<Unit> {
        return try {
            Timber.d("üîÑ Sincronizando pessoas do Firestore...")
            
            // Buscar todas as pessoas do Firestore
            val resultado = firestoreService.buscarTodasPessoas()
            
            resultado.onSuccess { pessoas ->
                // Salvar no cache local
                val entities = pessoas.map { it.toEntity() }
                pessoaDao.inserirTodas(entities)
                
                Timber.d("‚úÖ ${pessoas.size} pessoas sincronizadas")
            }
            
            resultado.onFailure { error ->
                Timber.e(error, "‚ùå Erro na sincroniza√ß√£o")
            }
            
            resultado.map { }
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro fatal na sincroniza√ß√£o")
            Result.failure(e)
        }
    }
    
    /**
     * Salva pessoa (local + remoto)
     */
    suspend fun salvar(pessoa: Pessoa, ehAdmin: Boolean): Result<Unit> {
        return try {
            // Se n√£o for admin, marca como n√£o aprovado
            val pessoaFinal = if (!ehAdmin) {
                pessoa.copy(aprovado = false)
            } else {
                pessoa.copy(aprovado = true)
            }
            
            // Salvar no Firestore
            val resultado = firestoreService.salvarPessoa(pessoaFinal)
            
            resultado.onSuccess {
                // Salvar no cache local
                pessoaDao.inserir(pessoaFinal.toEntity())
                Timber.d("‚úÖ Pessoa salva: ${pessoaFinal.nome}")
            }
            
            resultado
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao salvar pessoa")
            Result.failure(e)
        }
    }
    
    /**
     * Atualiza pessoa existente
     */
    suspend fun atualizar(pessoa: Pessoa, ehAdmin: Boolean): Result<Unit> {
        return try {
            // Incrementar vers√£o
            val pessoaAtualizada = pessoa.copy(
                versao = pessoa.versao + 1,
                aprovado = ehAdmin // Admin aprova automaticamente
            )
            
            // Atualizar no Firestore
            val resultado = firestoreService.salvarPessoa(pessoaAtualizada)
            
            resultado.onSuccess {
                // Atualizar cache local
                pessoaDao.atualizar(pessoaAtualizada.toEntity())
            }
            
            resultado
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao atualizar pessoa")
            Result.failure(e)
        }
    }
    
    /**
     * Deleta pessoa
     */
    suspend fun deletar(pessoaId: String): Result<Unit> {
        return try {
            // Deletar do Firestore
            val resultado = firestoreService.deletarPessoa(pessoaId)
            
            resultado.onSuccess {
                // Deletar do cache local
                pessoaDao.deletarPorId(pessoaId)
            }
            
            resultado
            
        } catch (e: Exception) {
            Timber.e(e, "‚ùå Erro ao deletar pessoa")
            Result.failure(e)
        }
    }
    
    /**
     * Busca pessoas por nome
     */
    suspend fun buscarPorNome(termo: String): List<Pessoa> {
        // Buscar no cache local primeiro
        return pessoaDao.buscarPorNome(termo).map { it.toDomain() }
    }
    
    /**
     * Busca filhos de uma pessoa
     */
    suspend fun buscarFilhos(pessoaId: String): List<Pessoa> {
        return pessoaDao.buscarFilhos(pessoaId).map { it.toDomain() }
    }
    
    /**
     * Busca irm√£os
     */
    suspend fun buscarIrmaos(paiId: String?, maeId: String?, excluirId: String): List<Pessoa> {
        return pessoaDao.buscarIrmaos(paiId, maeId, excluirId).map { it.toDomain() }
    }
    
    /**
     * Conta total de pessoas
     */
    suspend fun contarPessoas(): Int {
        return pessoaDao.contarPessoas()
    }
}
```

---

### Arquivo: data/repository/FamiliaZeroRepository.kt

```kotlin
package com.raizesvivas.app.data.repository

import com.raizesvivas.app.data.remote.firebase.FirestoreService
import com.raizesvivas.app.domain.model.FamiliaZero
import kotlinx.coroutines.flow.Flow
import timber.log.Timber
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository para gerenciar a Fam√≠lia Zero
 */
@Singleton
class FamiliaZeroRepository @Inject constructor(
    private val firestoreService: FirestoreService
) {
    
    /**
     * Verifica se a Fam√≠lia Zero j√° foi criada
     */
    suspend fun existe(): Boolean {
        return firestoreService.familiaZeroExiste()
    }
    
    /**
     * Cria a Fam√≠lia Zero (apenas no primeiro acesso)
     */
    suspend fun criar(familiaZero: FamiliaZero): Result<Unit> {
        Timber.d("üå≥ Criando Fam√≠lia Zero...")
        return firestoreService.criarFamiliaZero(familiaZero)
    }
    
    /**
     * Busca a Fam√≠lia Zero
     */
    suspend fun buscar(): FamiliaZero? {
        return firestoreService.buscarFamiliaZero().getOrNull()
    }
    
    /**
     * Observa a Fam√≠lia Zero em tempo real
     */
    fun observar(): Flow<FamiliaZero?> {
        return firestoreService.observarFamiliaZero()
    }
}
```

---

## ‚úÖ Checklist de Verifica√ß√£o

Ap√≥s executar este prompt, verifique:

- [ ] Repositories compilam sem erros
- [ ] FirestoreService est√° funcional
- [ ] Hilt consegue injetar repositories
- [ ] Sincroniza√ß√£o local ‚Üî remoto funciona
- [ ] Logs do Timber aparecem corretamente

---

## üîú Pr√≥ximo Passo

**Prompt 06**: Criar telas de autentica√ß√£o (Login, Cadastro, Recuperar Senha)