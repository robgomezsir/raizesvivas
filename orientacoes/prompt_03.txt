# üìã Prompt 03 - Models de Dom√≠nio e Entities do Room

## üéØ Objetivo
Criar todas as classes de modelo de dom√≠nio e entities do Room Database para cache local.

---

## üì¶ PARTE 1: Models de Dom√≠nio

### Arquivo: domain/model/Pessoa.kt

```kotlin
package com.raizesvivas.app.domain.model

import java.util.Date

/**
 * Modelo de dom√≠nio representando uma pessoa na √°rvore geneal√≥gica
 * 
 * Esta classe representa uma pessoa com todos os seus dados e relacionamentos.
 * √â a entidade central do sistema.
 */
data class Pessoa(
    val id: String = "",
    val nome: String = "",
    val dataNascimento: Date? = null,
    val dataFalecimento: Date? = null,
    val localNascimento: String? = null,
    val localResidencia: String? = null,
    val profissao: String? = null,
    val biografia: String? = null,
    
    // Relacionamentos
    val pai: String? = null,              // ID do pai
    val mae: String? = null,              // ID da m√£e
    val conjugeAtual: String? = null,     // ID do c√¥njuge atual
    val exConjuges: List<String> = emptyList(), // IDs de ex-c√¥njuges
    val filhos: List<String> = emptyList(),     // IDs dos filhos
    
    // Metadados
    val fotoUrl: String? = null,
    val criadoPor: String = "",           // UserID de quem criou
    val criadoEm: Date = Date(),
    val modificadoPor: String = "",       // UserID de quem modificou por √∫ltimo
    val modificadoEm: Date = Date(),
    val aprovado: Boolean = false,        // Se foi aprovado por admin
    val versao: Int = 1,                  // Controle de vers√£o para conflitos
    
    // Flags especiais
    val ehFamiliaZero: Boolean = false,   // True apenas para o casal raiz
    val distanciaFamiliaZero: Int = 0     // N√∫mero de graus at√© a Fam√≠lia Zero
) {
    /**
     * Nome normalizado para busca (sem acentos, min√∫sculas)
     */
    val nomeNormalizado: String
        get() = nome.lowercase()
            .replace("√°", "a")
            .replace("√©", "e")
            .replace("√≠", "i")
            .replace("√≥", "o")
            .replace("√∫", "u")
            .replace("√£", "a")
            .replace("√µ", "o")
            .replace("√ß", "c")
    
    /**
     * Verifica se a pessoa est√° viva
     */
    val estaVivo: Boolean
        get() = dataFalecimento == null
    
    /**
     * Calcula idade atual ou idade ao falecer
     */
    fun calcularIdade(): Int? {
        val dataNasc = dataNascimento ?: return null
        val dataReferencia = dataFalecimento ?: Date()
        
        val diff = dataReferencia.time - dataNasc.time
        val anos = diff / (1000L * 60 * 60 * 24 * 365)
        
        return anos.toInt()
    }
    
    /**
     * Retorna nome formatado para exibi√ß√£o
     */
    fun getNomeExibicao(): String {
        return if (nome.isNotBlank()) nome else "Sem nome"
    }
}
```

---

### Arquivo: domain/model/Usuario.kt

```kotlin
package com.raizesvivas.app.domain.model

import java.util.Date

/**
 * Modelo de dom√≠nio representando um usu√°rio do app
 * 
 * Um usu√°rio √© algu√©m que tem login no app e pode estar
 * vinculado a uma pessoa espec√≠fica na √°rvore geneal√≥gica.
 */
data class Usuario(
    val id: String = "",                  // Firebase Auth UID
    val nome: String = "",
    val email: String = "",
    val fotoUrl: String? = null,
    
    // V√≠nculo com a √°rvore geneal√≥gica
    val pessoaVinculada: String? = null,  // ID da pessoa que representa este usu√°rio
    
    // Permiss√µes
    val ehAdministrador: Boolean = false,
    
    // Refer√™ncia r√°pida √† Fam√≠lia Zero
    val familiaZeroPai: String? = null,   // ID do patriarca
    val familiaZeroMae: String? = null,   // ID da matriarca
    
    // Flags de controle
    val primeiroAcesso: Boolean = true,   // True se ainda n√£o completou onboarding
    
    // Metadados
    val criadoEm: Date = Date()
) {
    /**
     * Verifica se o usu√°rio est√° vinculado a algu√©m na √°rvore
     */
    val estaVinculado: Boolean
        get() = pessoaVinculada != null
    
    /**
     * Verifica se a Fam√≠lia Zero j√° foi definida
     */
    val familiaZeroDefinida: Boolean
        get() = familiaZeroPai != null && familiaZeroMae != null
}
```

---

### Arquivo: domain/model/FamiliaZero.kt

```kotlin
package com.raizesvivas.app.domain.model

import java.util.Date

/**
 * Modelo representando a Fam√≠lia Zero (raiz da √°rvore)
 * 
 * A Fam√≠lia Zero √© o casal patriarca/matriarca que serve
 * como raiz de toda a √°rvore geneal√≥gica. S√≥ pode existir
 * UMA Fam√≠lia Zero por √°rvore.
 */
data class FamiliaZero(
    val id: String = "raiz",              // Sempre "raiz" (singleton)
    val pai: String = "",                 // ID do patriarca
    val mae: String = "",                 // ID da matriarca
    val fundadoPor: String = "",          // UserID de quem fundou
    val fundadoEm: Date = Date(),
    val locked: Boolean = true,           // Sempre true - impede dele√ß√£o
    val arvoreNome: String = ""           // Ex: "Fam√≠lia Silva"
) {
    /**
     * Verifica se a Fam√≠lia Zero est√° v√°lida
     */
    val estaValida: Boolean
        get() = pai.isNotBlank() && mae.isNotBlank()
    
    /**
     * Retorna nome da √°rvore para exibi√ß√£o
     */
    fun getNomeArvore(): String {
        return if (arvoreNome.isNotBlank()) arvoreNome else "√Årvore Geneal√≥gica"
    }
}
```

---

### Arquivo: domain/model/Convite.kt

```kotlin
package com.raizesvivas.app.domain.model

import java.util.Date

/**
 * Status poss√≠veis de um convite
 */
enum class StatusConvite {
    PENDENTE,
    ACEITO,
    REJEITADO,
    EXPIRADO
}

/**
 * Modelo representando um convite para entrar na √°rvore
 * 
 * Apenas administradores podem criar convites.
 * Convites expiram em 7 dias.
 */
data class Convite(
    val id: String = "",
    val emailConvidado: String = "",
    val convidadoPor: String = "",        // UserID de quem convidou
    val pessoaVinculada: String? = null,  // ID da pessoa que o convidado representa (opcional)
    val status: StatusConvite = StatusConvite.PENDENTE,
    val criadoEm: Date = Date(),
    val expiraEm: Date = Date(System.currentTimeMillis() + (7 * 24 * 60 * 60 * 1000)) // 7 dias
) {
    /**
     * Verifica se o convite ainda est√° v√°lido
     */
    val estaValido: Boolean
        get() = status == StatusConvite.PENDENTE && Date().before(expiraEm)
    
    /**
     * Verifica se o convite expirou
     */
    val expirou: Boolean
        get() = Date().after(expiraEm)
}
```

---

### Arquivo: domain/model/EdicaoPendente.kt

```kotlin
package com.raizesvivas.app.domain.model

import java.util.Date

/**
 * Status de uma edi√ß√£o pendente
 */
enum class StatusEdicao {
    PENDENTE,
    APROVADA,
    REJEITADA
}

/**
 * Modelo representando uma edi√ß√£o aguardando aprova√ß√£o
 * 
 * Quando um usu√°rio n√£o-admin edita uma pessoa, a edi√ß√£o
 * fica pendente at√© ser aprovada por um administrador.
 */
data class EdicaoPendente(
    val id: String = "",
    val pessoaId: String = "",            // ID da pessoa sendo editada
    val camposAlterados: Map<String, Any> = emptyMap(), // Campos que foram modificados
    val editadoPor: String = "",          // UserID de quem editou
    val status: StatusEdicao = StatusEdicao.PENDENTE,
    val criadoEm: Date = Date(),
    val revisadoEm: Date? = null,
    val revisadoPor: String? = null       // UserID do admin que revisou
) {
    /**
     * Verifica se ainda est√° aguardando aprova√ß√£o
     */
    val estaPendente: Boolean
        get() = status == StatusEdicao.PENDENTE
}
```

---

### Arquivo: domain/model/ParentescoTipo.kt

```kotlin
package com.raizesvivas.app.domain.model

/**
 * Enum representando todos os tipos poss√≠veis de parentesco
 * 
 * Este enum √© usado pelo algoritmo de c√°lculo de parentesco
 * para determinar a rela√ß√£o entre duas pessoas.
 */
enum class ParentescoTipo(val descricao: String, val grau: Int) {
    // Grau 0 - Mesma pessoa
    EU("Voc√™ mesmo", 0),
    
    // Grau 1 - Rela√ß√µes diretas
    PAI("Pai", 1),
    MAE("M√£e", 1),
    FILHO("Filho", 1),
    FILHA("Filha", 1),
    CONJUGE("C√¥njuge", 1),
    EX_CONJUGE("Ex-c√¥njuge", 1),
    
    // Grau 2 - Irm√£os e av√≥s
    IRMAO("Irm√£o", 2),
    IRMA("Irm√£", 2),
    MEIO_IRMAO("Meio-irm√£o", 2),
    MEIA_IRMA("Meia-irm√£", 2),
    AVO_PATERNO("Av√¥ paterno", 2),
    AVO_PATERNA("Av√≥ paterna", 2),
    AVO_MATERNO("Av√¥ materno", 2),
    AVO_MATERNA("Av√≥ materna", 2),
    NETO("Neto", 2),
    NETA("Neta", 2),
    
    // Grau 3 - Tios e sobrinhos
    TIO_PATERNO("Tio paterno", 3),
    TIA_PATERNA("Tia paterna", 3),
    TIO_MATERNO("Tio materno", 3),
    TIA_MATERNA("Tia materna", 3),
    SOBRINHO("Sobrinho", 3),
    SOBRINHA("Sobrinha", 3),
    BISNETO("Bisneto", 3),
    BISNETA("Bisneta", 3),
    BISAVO("Bisav√¥", 3),
    BISAVO_F("Bisav√≥", 3),
    
    // Grau 4 - Primos
    PRIMO("Primo", 4),
    PRIMA("Prima", 4),
    
    // Por afinidade (casamento)
    SOGRO("Sogro", 2),
    SOGRA("Sogra", 2),
    GENRO("Genro", 2),
    NORA("Nora", 2),
    CUNHADO("Cunhado", 2),
    CUNHADA("Cunhada", 2),
    PADRASTO("Padrasto", 2),
    MADRASTA("Madrasta", 2),
    ENTEADO("Enteado", 2),
    ENTEADA("Enteada", 2),
    
    // N√£o identificado
    PARENTE_DISTANTE("Parente distante", 99),
    DESCONHECIDO("Rela√ß√£o desconhecida", 999);
    
    /**
     * Retorna descri√ß√£o formatada para exibi√ß√£o
     */
    fun getDescricaoFormatada(nomePessoa: String): String {
        return "$nomePessoa √© seu(sua) $descricao"
    }
}
```

---

## üóÑÔ∏è PARTE 2: Entities do Room Database

### Arquivo: data/local/entities/PessoaEntity.kt

```kotlin
package com.raizesvivas.app.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.TypeConverters
import com.raizesvivas.app.data.local.Converters
import com.raizesvivas.app.domain.model.Pessoa
import java.util.Date

/**
 * Entity Room para armazenar pessoas localmente (cache)
 * 
 * Esta entity espelha os dados do Firestore para permitir
 * funcionamento offline do app.
 */
@Entity(tableName = "pessoas")
@TypeConverters(Converters::class)
data class PessoaEntity(
    @PrimaryKey
    val id: String,
    val nome: String,
    val dataNascimento: Date?,
    val dataFalecimento: Date?,
    val localNascimento: String?,
    val localResidencia: String?,
    val profissao: String?,
    val biografia: String?,
    
    // Relacionamentos
    val pai: String?,
    val mae: String?,
    val conjugeAtual: String?,
    val exConjuges: List<String>,
    val filhos: List<String>,
    
    // Metadados
    val fotoUrl: String?,
    val criadoPor: String,
    val criadoEm: Date,
    val modificadoPor: String,
    val modificadoEm: Date,
    val aprovado: Boolean,
    val versao: Int,
    
    // Flags especiais
    val ehFamiliaZero: Boolean,
    val distanciaFamiliaZero: Int,
    
    // Controle de sincroniza√ß√£o
    val sincronizadoEm: Date = Date(),
    val precisaSincronizar: Boolean = false
)

/**
 * Converte de Entity para Model de Dom√≠nio
 */
fun PessoaEntity.toDomain(): Pessoa {
    return Pessoa(
        id = id,
        nome = nome,
        dataNascimento = dataNascimento,
        dataFalecimento = dataFalecimento,
        localNascimento = localNascimento,
        localResidencia = localResidencia,
        profissao = profissao,
        biografia = biografia,
        pai = pai,
        mae = mae,
        conjugeAtual = conjugeAtual,
        exConjuges = exConjuges,
        filhos = filhos,
        fotoUrl = fotoUrl,
        criadoPor = criadoPor,
        criadoEm = criadoEm,
        modificadoPor = modificadoPor,
        modificadoEm = modificadoEm,
        aprovado = aprovado,
        versao = versao,
        ehFamiliaZero = ehFamiliaZero,
        distanciaFamiliaZero = distanciaFamiliaZero
    )
}

/**
 * Converte de Model de Dom√≠nio para Entity
 */
fun Pessoa.toEntity(
    precisaSincronizar: Boolean = false
): PessoaEntity {
    return PessoaEntity(
        id = id,
        nome = nome,
        dataNascimento = dataNascimento,
        dataFalecimento = dataFalecimento,
        localNascimento = localNascimento,
        localResidencia = localResidencia,
        profissao = profissao,
        biografia = biografia,
        pai = pai,
        mae = mae,
        conjugeAtual = conjugeAtual,
        exConjuges = exConjuges,
        filhos = filhos,
        fotoUrl = fotoUrl,
        criadoPor = criadoPor,
        criadoEm = criadoEm,
        modificadoPor = modificadoPor,
        modificadoEm = modificadoEm,
        aprovado = aprovado,
        versao = versao,
        ehFamiliaZero = ehFamiliaZero,
        distanciaFamiliaZero = distanciaFamiliaZero,
        sincronizadoEm = Date(),
        precisaSincronizar = precisaSincronizar
    )
}
```

---

### Arquivo: data/local/entities/UsuarioEntity.kt

```kotlin
package com.raizesvivas.app.data.local.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.TypeConverters
import com.raizesvivas.app.data.local.Converters
import com.raizesvivas.app.domain.model.Usuario
import java.util.Date

/**
 * Entity Room para armazenar dados do usu√°rio localmente
 */
@Entity(tableName = "usuarios")
@TypeConverters(Converters::class)
data class UsuarioEntity(
    @PrimaryKey
    val id: String,
    val nome: String,
    val email: String,
    val fotoUrl: String?,
    val pessoaVinculada: String?,
    val ehAdministrador: Boolean,
    val familiaZeroPai: String?,
    val familiaZeroMae: String?,
    val primeiroAcesso: Boolean,
    val criadoEm: Date
)

fun UsuarioEntity.toDomain(): Usuario {
    return Usuario(
        id = id,
        nome = nome,
        email = email,
        fotoUrl = fotoUrl,
        pessoaVinculada = pessoaVinculada,
        ehAdministrador = ehAdministrador,
        familiaZeroPai = familiaZeroPai,
        familiaZeroMae = familiaZeroMae,
        primeiroAcesso = primeiroAcesso,
        criadoEm = criadoEm
    )
}

fun Usuario.toEntity(): UsuarioEntity {
    return UsuarioEntity(
        id = id,
        nome = nome,
        email = email,
        fotoUrl = fotoUrl,
        pessoaVinculada = pessoaVinculada,
        ehAdministrador = ehAdministrador,
        familiaZeroPai = familiaZeroPai,
        familiaZeroMae = familiaZeroMae,
        primeiroAcesso = primeiroAcesso,
        criadoEm = criadoEm
    )
}
```

---

### Arquivo: data/local/Converters.kt

```kotlin
package com.raizesvivas.app.data.local

import androidx.room.TypeConverter
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.util.Date

/**
 * Converters do Room para tipos complexos
 * 
 * Room n√£o suporta nativamente alguns tipos como Date e List<String>.
 * Estes converters transformam esses tipos em tipos primitivos
 * que o Room consegue armazenar.
 */
class Converters {
    
    private val gson = Gson()
    
    /**
     * Converte Date para Long (timestamp)
     */
    @TypeConverter
    fun fromDate(date: Date?): Long? {
        return date?.time
    }
    
    /**
     * Converte Long (timestamp) para Date
     */
    @TypeConverter
    fun toDate(timestamp: Long?): Date? {
        return timestamp?.let { Date(it) }
    }
    
    /**
     * Converte List<String> para String JSON
     */
    @TypeConverter
    fun fromStringList(list: List<String>?): String? {
        return gson.toJson(list)
    }
    
    /**
     * Converte String JSON para List<String>
     */
    @TypeConverter
    fun toStringList(json: String?): List<String>? {
        if (json == null) return emptyList()
        val type = object : TypeToken<List<String>>() {}.type
        return gson.fromJson(json, type)
    }
    
    /**
     * Converte Map<String, Any> para String JSON
     */
    @TypeConverter
    fun fromMap(map: Map<String, Any>?): String? {
        return gson.toJson(map)
    }
    
    /**
     * Converte String JSON para Map<String, Any>
     */
    @TypeConverter
    fun toMap(json: String?): Map<String, Any>? {
        if (json == null) return emptyMap()
        val type = object : TypeToken<Map<String, Any>>() {}.type
        return gson.fromJson(json, type)
    }
}
```

---

## ‚úÖ Checklist de Verifica√ß√£o

Ap√≥s executar este prompt, verifique:

- [ ] Todos os models compilam sem erros
- [ ] Entities est√£o anotadas corretamente com Room
- [ ] Converters est√£o configurados
- [ ] Fun√ß√µes de convers√£o (toDomain/toEntity) funcionam
- [ ] N√£o h√° imports faltando

---

## üîú Pr√≥ximo Passo

**Prompt 04**: Criar DAOs e Database do Room