# üìã Prompt 04 - DAOs e Room Database

## üéØ Objetivo
Criar os DAOs (Data Access Objects) e a configura√ß√£o do Room Database para cache local.

---

## üìä PARTE 1: DAOs (Data Access Objects)

### Arquivo: data/local/dao/PessoaDao.kt

```kotlin
package com.raizesvivas.app.data.local.dao

import androidx.room.*
import com.raizesvivas.app.data.local.entities.PessoaEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO para opera√ß√µes com pessoas no banco local
 * 
 * Este DAO fornece m√©todos para:
 * - Buscar pessoas (todas, por ID, por relacionamentos)
 * - Inserir/atualizar/deletar pessoas
 * - Buscar pessoas que precisam sincronizar
 */
@Dao
interface PessoaDao {
    
    // ============================================
    // CONSULTAS (SELECT)
    // ============================================
    
    /**
     * Busca todas as pessoas ordenadas por nome
     * Retorna Flow para observar mudan√ßas em tempo real
     */
    @Query("SELECT * FROM pessoas ORDER BY nome ASC")
    fun observarTodasPessoas(): Flow<List<PessoaEntity>>
    
    /**
     * Busca todas as pessoas (uma vez)
     */
    @Query("SELECT * FROM pessoas ORDER BY nome ASC")
    suspend fun buscarTodasPessoas(): List<PessoaEntity>
    
    /**
     * Busca pessoa por ID
     */
    @Query("SELECT * FROM pessoas WHERE id = :pessoaId")
    suspend fun buscarPorId(pessoaId: String): PessoaEntity?
    
    /**
     * Observa pessoa por ID (atualiza automaticamente)
     */
    @Query("SELECT * FROM pessoas WHERE id = :pessoaId")
    fun observarPorId(pessoaId: String): Flow<PessoaEntity?>
    
    /**
     * Busca o casal da Fam√≠lia Zero
     */
    @Query("SELECT * FROM pessoas WHERE ehFamiliaZero = 1")
    suspend fun buscarFamiliaZero(): List<PessoaEntity>
    
    /**
     * Observa o casal da Fam√≠lia Zero
     */
    @Query("SELECT * FROM pessoas WHERE ehFamiliaZero = 1")
    fun observarFamiliaZero(): Flow<List<PessoaEntity>>
    
    /**
     * Busca filhos de uma pessoa
     */
    @Query("SELECT * FROM pessoas WHERE pai = :pessoaId OR mae = :pessoaId")
    suspend fun buscarFilhos(pessoaId: String): List<PessoaEntity>
    
    /**
     * Busca irm√£os (mesmo pai E mesma m√£e)
     */
    @Query("""
        SELECT * FROM pessoas 
        WHERE pai = :paiId 
        AND mae = :maeId 
        AND id != :excluirId
    """)
    suspend fun buscarIrmaos(
        paiId: String?,
        maeId: String?,
        excluirId: String
    ): List<PessoaEntity>
    
    /**
     * Busca pessoas por nome (pesquisa parcial, case-insensitive)
     */
    @Query("""
        SELECT * FROM pessoas 
        WHERE nome LIKE '%' || :termo || '%' 
        ORDER BY nome ASC
    """)
    suspend fun buscarPorNome(termo: String): List<PessoaEntity>
    
    /**
     * Busca pessoas aprovadas (vis√≠veis na √°rvore)
     */
    @Query("SELECT * FROM pessoas WHERE aprovado = 1 ORDER BY nome ASC")
    suspend fun buscarPessoasAprovadas(): List<PessoaEntity>
    
    /**
     * Busca pessoas aguardando aprova√ß√£o
     */
    @Query("SELECT * FROM pessoas WHERE aprovado = 0 ORDER BY criadoEm DESC")
    suspend fun buscarPessoasPendentes(): List<PessoaEntity>
    
    /**
     * Busca pessoas que precisam sincronizar com Firestore
     */
    @Query("SELECT * FROM pessoas WHERE precisaSincronizar = 1")
    suspend fun buscarPessoasParaSincronizar(): List<PessoaEntity>
    
    /**
     * Busca pessoas vivas
     */
    @Query("SELECT * FROM pessoas WHERE dataFalecimento IS NULL ORDER BY nome ASC")
    suspend fun buscarPessoasVivas(): List<PessoaEntity>
    
    /**
     * Busca pessoas falecidas
     */
    @Query("SELECT * FROM pessoas WHERE dataFalecimento IS NOT NULL ORDER BY dataFalecimento DESC")
    suspend fun buscarPessoasFalecidas(): List<PessoaEntity>
    
    /**
     * Conta total de pessoas
     */
    @Query("SELECT COUNT(*) FROM pessoas")
    suspend fun contarPessoas(): Int
    
    /**
     * Conta total de pessoas aprovadas
     */
    @Query("SELECT COUNT(*) FROM pessoas WHERE aprovado = 1")
    suspend fun contarPessoasAprovadas(): Int
    
    // ============================================
    // INSER√á√ÉO E ATUALIZA√á√ÉO
    // ============================================
    
    /**
     * Insere uma pessoa (substitui se j√° existir)
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun inserir(pessoa: PessoaEntity)
    
    /**
     * Insere m√∫ltiplas pessoas de uma vez
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun inserirTodas(pessoas: List<PessoaEntity>)
    
    /**
     * Atualiza uma pessoa existente
     */
    @Update
    suspend fun atualizar(pessoa: PessoaEntity)
    
    /**
     * Atualiza m√∫ltiplas pessoas
     */
    @Update
    suspend fun atualizarTodas(pessoas: List<PessoaEntity>)
    
    /**
     * Marca pessoa como precisando sincronizar
     */
    @Query("UPDATE pessoas SET precisaSincronizar = 1 WHERE id = :pessoaId")
    suspend fun marcarParaSincronizar(pessoaId: String)
    
    /**
     * Marca pessoa como sincronizada
     */
    @Query("UPDATE pessoas SET precisaSincronizar = 0, sincronizadoEm = :timestamp WHERE id = :pessoaId")
    suspend fun marcarComoSincronizada(pessoaId: String, timestamp: Long = System.currentTimeMillis())
    
    // ============================================
    // DELE√á√ÉO
    // ============================================
    
    /**
     * Deleta uma pessoa
     */
    @Delete
    suspend fun deletar(pessoa: PessoaEntity)
    
    /**
     * Deleta pessoa por ID
     */
    @Query("DELETE FROM pessoas WHERE id = :pessoaId")
    suspend fun deletarPorId(pessoaId: String)
    
    /**
     * Deleta todas as pessoas (use com cuidado!)
     */
    @Query("DELETE FROM pessoas")
    suspend fun deletarTodas()
    
    /**
     * Deleta pessoas n√£o sincronizadas (limpeza de cache)
     */
    @Query("DELETE FROM pessoas WHERE precisaSincronizar = 0 AND sincronizadoEm < :timestamp")
    suspend fun limparCacheAntigo(timestamp: Long)
}
```

---

### Arquivo: data/local/dao/UsuarioDao.kt

```kotlin
package com.raizesvivas.app.data.local.dao

import androidx.room.*
import com.raizesvivas.app.data.local.entities.UsuarioEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO para opera√ß√µes com usu√°rios no banco local
 */
@Dao
interface UsuarioDao {
    
    /**
     * Busca usu√°rio por ID
     */
    @Query("SELECT * FROM usuarios WHERE id = :userId")
    suspend fun buscarPorId(userId: String): UsuarioEntity?
    
    /**
     * Observa usu√°rio por ID (atualiza automaticamente)
     */
    @Query("SELECT * FROM usuarios WHERE id = :userId")
    fun observarPorId(userId: String): Flow<UsuarioEntity?>
    
    /**
     * Busca todos os usu√°rios
     */
    @Query("SELECT * FROM usuarios ORDER BY nome ASC")
    suspend fun buscarTodos(): List<UsuarioEntity>
    
    /**
     * Busca administradores
     */
    @Query("SELECT * FROM usuarios WHERE ehAdministrador = 1")
    suspend fun buscarAdministradores(): List<UsuarioEntity>
    
    /**
     * Insere ou atualiza usu√°rio
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun inserir(usuario: UsuarioEntity)
    
    /**
     * Atualiza usu√°rio
     */
    @Update
    suspend fun atualizar(usuario: UsuarioEntity)
    
    /**
     * Atualiza flag de primeiro acesso
     */
    @Query("UPDATE usuarios SET primeiroAcesso = :valor WHERE id = :userId")
    suspend fun atualizarPrimeiroAcesso(userId: String, valor: Boolean)
    
    /**
     * Atualiza pessoa vinculada
     */
    @Query("UPDATE usuarios SET pessoaVinculada = :pessoaId WHERE id = :userId")
    suspend fun vincularPessoa(userId: String, pessoaId: String)
    
    /**
     * Atualiza Fam√≠lia Zero
     */
    @Query("UPDATE usuarios SET familiaZeroPai = :paiId, familiaZeroMae = :maeId WHERE id = :userId")
    suspend fun atualizarFamiliaZero(userId: String, paiId: String, maeId: String)
    
    /**
     * Deleta usu√°rio
     */
    @Delete
    suspend fun deletar(usuario: UsuarioEntity)
    
    /**
     * Deleta todos os usu√°rios (logout completo)
     */
    @Query("DELETE FROM usuarios")
    suspend fun deletarTodos()
}
```

---

## üóÑÔ∏è PARTE 2: Configura√ß√£o do Room Database

### Arquivo: data/local/RaizesVivasDatabase.kt

```kotlin
package com.raizesvivas.app.data.local

import androidx.room.Database
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import com.raizesvivas.app.data.local.dao.PessoaDao
import com.raizesvivas.app.data.local.dao.UsuarioDao
import com.raizesvivas.app.data.local.entities.PessoaEntity
import com.raizesvivas.app.data.local.entities.UsuarioEntity

/**
 * Banco de dados local do app Ra√≠zes Vivas
 * 
 * Este banco usa Room para armazenar dados localmente,
 * permitindo funcionamento offline e melhor performance.
 * 
 * Vers√£o 1: Schema inicial com pessoas e usu√°rios
 */
@Database(
    entities = [
        PessoaEntity::class,
        UsuarioEntity::class
    ],
    version = 1,
    exportSchema = true
)
@TypeConverters(Converters::class)
abstract class RaizesVivasDatabase : RoomDatabase() {
    
    /**
     * DAO para opera√ß√µes com pessoas
     */
    abstract fun pessoaDao(): PessoaDao
    
    /**
     * DAO para opera√ß√µes com usu√°rios
     */
    abstract fun usuarioDao(): UsuarioDao
    
    companion object {
        /**
         * Nome do arquivo do banco de dados
         */
        const val DATABASE_NAME = "raizes_vivas.db"
    }
}
```

---

## ‚öôÔ∏è PARTE 3: M√≥dulo Hilt para Database

### Arquivo: di/DatabaseModule.kt

```kotlin
package com.raizesvivas.app.di

import android.content.Context
import androidx.room.Room
import com.raizesvivas.app.data.local.RaizesVivasDatabase
import com.raizesvivas.app.data.local.dao.PessoaDao
import com.raizesvivas.app.data.local.dao.UsuarioDao
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

/**
 * M√≥dulo Hilt para prover inst√¢ncias do Room Database
 * 
 * Este m√≥dulo cria e configura o banco de dados local.
 */
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    /**
     * Prov√™ inst√¢ncia do Room Database
     */
    @Provides
    @Singleton
    fun provideDatabase(
        @ApplicationContext context: Context
    ): RaizesVivasDatabase {
        return Room.databaseBuilder(
            context,
            RaizesVivasDatabase::class.java,
            RaizesVivasDatabase.DATABASE_NAME
        )
            // Permite queries na main thread (apenas para debug)
            // REMOVER EM PRODU√á√ÉO
            .fallbackToDestructiveMigration() // Recria DB se vers√£o mudar
            .build()
    }
    
    /**
     * Prov√™ DAO de Pessoa
     */
    @Provides
    @Singleton
    fun providePessoaDao(
        database: RaizesVivasDatabase
    ): PessoaDao {
        return database.pessoaDao()
    }
    
    /**
     * Prov√™ DAO de Usu√°rio
     */
    @Provides
    @Singleton
    fun provideUsuarioDao(
        database: RaizesVivasDatabase
    ): UsuarioDao {
        return database.usuarioDao()
    }
}
```

---

## üß™ PARTE 4: Testes Unit√°rios para DAOs

### Arquivo: test/data/local/dao/PessoaDaoTest.kt

```kotlin
package com.raizesvivas.app.data.local.dao

import android.content.Context
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.raizesvivas.app.data.local.RaizesVivasDatabase
import com.raizesvivas.app.data.local.entities.PessoaEntity
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.util.Date

/**
 * Testes para o PessoaDao
 * 
 * Estes testes verificam se as opera√ß√µes do banco de dados
 * est√£o funcionando corretamente.
 */
@RunWith(AndroidJUnit4::class)
class PessoaDaoTest {
    
    private lateinit var database: RaizesVivasDatabase
    private lateinit var pessoaDao: PessoaDao
    
    /**
     * Configura banco de dados em mem√≥ria antes de cada teste
     */
    @Before
    fun setup() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        database = Room.inMemoryDatabaseBuilder(
            context,
            RaizesVivasDatabase::class.java
        ).build()
        pessoaDao = database.pessoaDao()
    }
    
    /**
     * Fecha banco de dados ap√≥s cada teste
     */
    @After
    fun tearDown() {
        database.close()
    }
    
    /**
     * Testa inser√ß√£o e busca de pessoa
     */
    @Test
    fun inserirEBuscarPessoa() = runBlocking {
        // Arrange
        val pessoa = criarPessoaTeste(
            id = "pessoa1",
            nome = "Jo√£o Silva"
        )
        
        // Act
        pessoaDao.inserir(pessoa)
        val resultado = pessoaDao.buscarPorId("pessoa1")
        
        // Assert
        assertNotNull(resultado)
        assertEquals("Jo√£o Silva", resultado?.nome)
    }
    
    /**
     * Testa busca de filhos
     */
    @Test
    fun buscarFilhos() = runBlocking {
        // Arrange
        val pai = criarPessoaTeste("pai1", "Pai")
        val mae = criarPessoaTeste("mae1", "M√£e")
        val filho1 = criarPessoaTeste("filho1", "Filho 1", pai = "pai1", mae = "mae1")
        val filho2 = criarPessoaTeste("filho2", "Filho 2", pai = "pai1", mae = "mae1")
        
        pessoaDao.inserir(pai)
        pessoaDao.inserir(mae)
        pessoaDao.inserir(filho1)
        pessoaDao.inserir(filho2)
        
        // Act
        val filhos = pessoaDao.buscarFilhos("pai1")
        
        // Assert
        assertEquals(2, filhos.size)
        assertTrue(filhos.any { it.nome == "Filho 1" })
        assertTrue(filhos.any { it.nome == "Filho 2" })
    }
    
    /**
     * Testa busca de irm√£os
     */
    @Test
    fun buscarIrmaos() = runBlocking {
        // Arrange
        val irmao1 = criarPessoaTeste("i1", "Irm√£o 1", pai = "pai", mae = "mae")
        val irmao2 = criarPessoaTeste("i2", "Irm√£o 2", pai = "pai", mae = "mae")
        val irmao3 = criarPessoaTeste("i3", "Irm√£o 3", pai = "pai", mae = "mae")
        
        pessoaDao.inserir(irmao1)
        pessoaDao.inserir(irmao2)
        pessoaDao.inserir(irmao3)
        
        // Act
        val irmaos = pessoaDao.buscarIrmaos("pai", "mae", "i1")
        
        // Assert
        assertEquals(2, irmaos.size)
        assertFalse(irmaos.any { it.id == "i1" }) // N√£o inclui a pr√≥pria pessoa
    }
    
    /**
     * Testa busca por nome
     */
    @Test
    fun buscarPorNome() = runBlocking {
        // Arrange
        pessoaDao.inserir(criarPessoaTeste("1", "Jo√£o Silva"))
        pessoaDao.inserir(criarPessoaTeste("2", "Maria Silva"))
        pessoaDao.inserir(criarPessoaTeste("3", "Pedro Santos"))
        
        // Act
        val resultado = pessoaDao.buscarPorNome("Silva")
        
        // Assert
        assertEquals(2, resultado.size)
    }
    
    /**
     * Testa contagem de pessoas
     */
    @Test
    fun contarPessoas() = runBlocking {
        // Arrange
        pessoaDao.inserir(criarPessoaTeste("1", "Pessoa 1"))
        pessoaDao.inserir(criarPessoaTeste("2", "Pessoa 2"))
        pessoaDao.inserir(criarPessoaTeste("3", "Pessoa 3"))
        
        // Act
        val total = pessoaDao.contarPessoas()
        
        // Assert
        assertEquals(3, total)
    }
    
    /**
     * Fun√ß√£o auxiliar para criar pessoa de teste
     */
    private fun criarPessoaTeste(
        id: String,
        nome: String,
        pai: String? = null,
        mae: String? = null
    ) = PessoaEntity(
        id = id,
        nome = nome,
        dataNascimento = Date(),
        dataFalecimento = null,
        localNascimento = null,
        localResidencia = null,
        profissao = null,
        biografia = null,
        pai = pai,
        mae = mae,
        conjugeAtual = null,
        exConjuges = emptyList(),
        filhos = emptyList(),
        fotoUrl = null,
        criadoPor = "teste",
        criadoEm = Date(),
        modificadoPor = "teste",
        modificadoEm = Date(),
        aprovado = true,
        versao = 1,
        ehFamiliaZero = false,
        distanciaFamiliaZero = 0,
        precisaSincronizar = false
    )
}
```

---

## ‚úÖ Checklist de Verifica√ß√£o

Ap√≥s executar este prompt, verifique:

- [ ] DAOs compilam sem erros
- [ ] Database est√° configurado corretamente
- [ ] Hilt consegue injetar DAOs
- [ ] Testes unit√°rios passam
- [ ] Queries SQL est√£o corretas
- [ ] TypeConverters funcionam

---

## üîç Como Testar Manualmente

Adicione em algum ViewModel ou Activity temporariamente:

```kotlin
@Inject lateinit var pessoaDao: PessoaDao

viewModelScope.launch {
    val count = pessoaDao.contarPessoas()
    Timber.d("Total de pessoas no banco: $count")
}
```

---

## üîú Pr√≥ximo Passo

**Prompt 05**: Criar FirestoreService e Repositories